import turtle as tl
from time import *
import doctest
import pickle
import ctypes

# Paramètres fenêtre turtle

user32 = ctypes.windll.user32 
tl.setup(user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)) #On récupère les dimensions de l'écrans et on adapte la fenêtre turtle
tl.title("Les tours de Hanoï")
tl.bgcolor("lightgrey")

tl.hideturtle()
souris = tl.Turtle() #Instance de l'objet Turtle permettant de créer les boutons pour la souris

#L'instance créée par défaut est gardée pour le dessin du plateau et des disques à chaque étape

###################################################################################################################
########################################### Panneau de commande Turtle ############################################
###################################################################################################################

def rectangle(L, l):
    souris.down()
    for i in range(2):
        souris.forward(L)
        souris.right(90)
        souris.forward(l)
        souris.right(90)
    souris.up()

souris.hideturtle()
souris.speed(0)
souris.up()
cos_defaut = (-(user32.GetSystemMetrics(0)/2)+100, (user32.GetSystemMetrics(1)/2)-100)
souris.goto(cos_defaut)
rectangle(150,400)
souris.goto(cos_defaut[0]+75, cos_defaut[1]-30)
souris.write("Les tours de Hanoï",align="center", font=("Arial",10,"bold"))
souris.goto(souris.xcor(),souris.ycor()-35)
souris.write("~~~~~~~~~~~~~~",align="center", font=("Arial",10,"bold"))
boutons = ["Tour 0","Tour 1","Tour 2","Annuler","Abandonner","Quitter"]
for i in range(len(boutons)):
    souris.goto(cos_defaut[0]+20,cos_defaut[1]-(i+2)*50)
    print(i,"=",souris.pos())
    rectangle(110, 30)
    souris.goto(souris.xcor()+55, souris.ycor()-24)
    souris.write(boutons[i],align="center", font=("Arial",10, "normal"))
    
# Coordonnées boutons (coin supérieur gauche)
#0 = (-840.00,340.00)
#1 = (-840.00,290.00)
#2 = (-840.00,240.00)
#3 = (-840.00,190.00)
#4 = (-840.00,140.00)
#5 = (-(screensizex/2)+120,screensize/2 - 450)

screensizeX, screensizeY = user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)

def boutons(x,y):
    print(x,y)
    dep = (None,None)
    if -(screensizeX/2)+120 <= x <= (screensizeX/2)+230:
        if (screensizeY/2)-450 >= y >= (screensizeY/2)-480: #Quitter
            tl.clear()
            souris.clear()
            tl.up()
            tl.goto(0,0)
            tl.write("Merci d'avoir joué", align="center", font=("Arial",40,"bold"))
            sleep(2)
            tl.bye()
        elif (screensizeY/2)-400 >= y >= (screensizeY/2)-430: #Annuler
            return
        elif (screensizeY/2)-350 >= y >= (screensizeY/2)-380: #Tour 2
            if dep[0] is None:
                dep[0] = 2
            elif dep[1] is None:
                dep[1] = 2
        elif (screensizeY/2)-300 >= y >= (screensizeY/2)-330: #Tour 1
            if dep[0] is None:
                dep[0] = 2
            elif dep[1] is None:
                dep[1] = 2
        elif (screensizeY/2)-250 >= y >= (screensizeY/2)-280: #Tour 0
            if dep[0] is None:
                dep[0] = 2
            elif dep[1] is None:
                dep[1] = 2
    if dep[0] is not None and dep[1] is not None:
        lireCoords()
            

###################################################################################################################
##################################### Partie A : Plateau de jeu et listes #########################################
###################################################################################################################

def init(n: int) -> list:
    """Renvoie la liste initiale
    >>> init(3)
    [[3, 2, 1], [], []]
    """

    return [[i for i in range(n, 0, -1)], [], []]


def nbDisques(plateau: list, numtour: int) -> int:
    """(liste config, num tour) -> nb disques tour
    >>> nbDisques(init(3), 0)
    3
    """

    return len(plateau[numtour])


def disqueSup(plateau: list, numtour: int) -> int:
    """(liste config, num tour) -> num disque supérieur de la tour (-1 si incorrect)
    >>> disqueSup(init(3), 0)
    1
    """

    if nbDisques(plateau, numtour) == 0:
        return -1
    return plateau[numtour][-1]


def posDisque(plateau: list, numdisque: int) -> int:
    """(liste config, num disque) -> position disque (num tour)
    >>> posDisque(init(3), 2)
    0
    """

    for i in range(len(plateau)):
        if numdisque in plateau[i]:
            return i


def verifDep1(plateau: list, nt1: int, nt2: int) -> bool:
    """(liste config, pos1, pos2) -> bool (déplacement possible ou non)
    >>> verifDep1(init(3), 0, 2)
    True
    >>> verifDep1([[3], [2, 1], []], 0, 1)
    False
    """

    if nbDisques(plateau, nt1) != 0 and (
        disqueSup(plateau, nt1) < disqueSup(plateau, nt2)
        or nbDisques(plateau, nt2) == 0
    ):
        return True
    return False


def verifVictoire(plateau: list, n: int) -> bool:
    """(liste config, nb disques) -> bool (victoire)
    >>> verifVictoire([[], [], [3, 2, 1]], 3)
    True
    """

    return plateau == [[], [], [i for i in range(n, 0, -1)]]

###################################################################################################################
####################################### Partie B : Graphisme avec Turtle ##########################################
###################################################################################################################

tl.speed(0)

def dessinePlateau(n: int):
    """Dessine le plateau de jeu vide pouvant recevoir n disques"""

    tl.color("black")
    diametre_grandDisque = 40 + 30 * (n - 1)
    tl.up()
    tl.goto(-(diametre_grandDisque*1.5 + 40), -(20*(n+2))/2) #Permet dde centrer le plateau de jeu dans la fenêtre
    tl.down()
    # Base du plateau
    for i in range(2):
        tl.forward(80 + diametre_grandDisque * 3)
        tl.right(90)
        tl.forward(20)
        tl.right(90)
    # Tours
    for i in range(3):
        tl.forward(20 + diametre_grandDisque / 2 - 3)
        tl.left(90)
        tl.forward(20 * (n + 1))
        tl.right(90)
        tl.forward(6)
        tl.right(90)
        tl.forward(20 * (n + 1))
        pos = tl.pos()
        tl.up()
        tl.goto(pos[0]-3, pos[1]-18)
        tl.down()
        tl.write("Tour "+str(i), font=("Arial",10,"bold"), align="center")
        tl.up()
        tl.goto(pos)
        tl.down()
        tl.left(90)
        tl.forward(diametre_grandDisque / 2 - 3)


def dessineDisque(nd: int, plateau: list, n: int):
    """Trouve les coordonnées du disque nd et le dessine"""

    tl.up()
    diametre_grandDisque = 40 + 30 * (n - 1)
    cos_defaut = (-(diametre_grandDisque*1.5 + 40), -(20*(n+2))/2)
    tl.goto(cos_defaut)
    tour_disque = posDisque(plateau, nd)
    ind_disque = None
    for i in range(len(plateau[tour_disque])):
        if plateau[tour_disque][i] == nd:
            ind_disque = i
    tour_disque += 1
    tl.goto(
        cos_defaut[0]
        + 20 * tour_disque
        + (40 + 30 * (n - 1)) * (tour_disque - 1)
        + 15 * (n - nd),
        cos_defaut[1] + 20 * (ind_disque + 1),
    )
    tl.down()
    tl.color("black")
    tl.fillcolor("grey")
    tl.begin_fill()
    for i in range(2):
        tl.forward(40 + 30 * (nd - 1))
        tl.right(90)
        tl.forward(20)
        tl.right(90)
    tl.end_fill()


def effaceDisque(nd: int, plateau: list, n: int):
    """Trouve les coordonnées du disque nd et l'efface"""

    tl.up()
    diametre_grandDisque = 40 + 30 * (n - 1)
    cos_defaut = (-(diametre_grandDisque*1.5 + 40), -(20*(n+2))/2)
    tl.goto(cos_defaut)
    tour_disque = posDisque(plateau, nd)
    ind_disque = None
    for i in range(len(plateau[tour_disque])):
        if plateau[tour_disque][i] == nd:
            ind_disque = i
    tour_disque += 1
    tl.goto(
        cos_defaut[0]
        + 20 * tour_disque
        + (40 + 30 * (n - 1)) * (tour_disque - 1)
        + 15 * (n - nd),
        cos_defaut[1] + 20 * (ind_disque + 1),
    )
    tl.down()
    tl.color("lightgrey")
    tl.fillcolor("lightgrey")
    tl.begin_fill()
    #Efface le disque supérieur
    for i in range(2):
        tl.forward(40 + 30 * (nd - 1))
        tl.right(90)
        tl.forward(20)
        tl.right(90)
    tl.end_fill()
    tl.up()
    tl.goto(tl.pos()[0], tl.pos()[1] - 20)
    tl.color("black")
    tl.down()
    tl.forward((40 + 30 * (nd - 1)) / 2 - 3)
    tl.left(90)
    tl.forward(20)
    tl.backward(20)
    tl.right(90)
    tl.forward(6)
    tl.left(90)
    tl.forward(20)
    tl.backward(20)
    tl.right(90)
    tl.forward((40 + 30 * (nd - 1)) / 2 - 2)


def effaceTout(plateau: list, n: int):
    """Efface tous les disques"""

    for i in range(1, n + 1):
        effaceDisque(i, plateau, n)

###################################################################################################################
################################### Partie C : Interactions avec le joueur ########################################
###################################################################################################################

def lireCoords(plateau: list, dep:int, arr:int) -> tuple[int, int]:
    """Reçoit 2 tours puis renvoie le déplacement si il est possible, une erreur sinon"""
    
    # ATTENTION : Nous partons du principe que les 3 tours portent les numéros 0, 1 et 2 !
    
    verif = True
    if dep == arr or dep not in[0,1,2] or arr not in [0,1,2] or len(plateau[dep]) == 0:
        verif = False
    
    if verif:
        return dep, arr
    return -1,-1
        
    
    


def jouerUnCoup(plateau: list, n: int, x:int, y:int):
    """Récupère les coordonnées du clique du joueur (trigger par le clique) et déplace le disque + modifie la configuration"""

    dep = (None,None)
    if -(screensizeX/2)+120 <= x <= (screensizeX/2)+230:
        if (screensizeY/2)-350 >= y >= (screensizeY/2)-380: #Tour 2
            if dep[0] is None:
                dep[0] = 2
            elif dep[1] is None:
                dep[1] = 2
        elif (screensizeY/2)-300 >= y >= (screensizeY/2)-330: #Tour 1
            if dep[0] is None:
                dep[0] = 1
            elif dep[1] is None:
                dep[1] = 1
        elif (screensizeY/2)-250 >= y >= (screensizeY/2)-280: #Tour 0
            if dep[0] is None:
                dep[0] = 0
            elif dep[1] is None:
                dep[1] = 0
                
    if dep[0] is not None and dep[1] is not None:
        tour_dep, tour_arr = lireCoords(plateau, dep[0],dep[1])
        dep = (None, None)
                
    tour_dep, tour_arr = lireCoords(plateau)
    effaceDisque(disqueSup(plateau, tour_dep), plateau, n)
    plateau[tour_arr].append(disqueSup(plateau, tour_dep))
    plateau[tour_dep].pop(-1)
    dessineDisque(disqueSup(plateau, tour_arr), plateau, n)


def boucleJeu(plateau: list, n: int) -> tuple[int, float, bool]:
    """Interragit avec l'utilisateur pour déplacer des disques jusqu'à la victoire"""
    
    temps1 = time()
    
    with open("cpt","wb") as cptFile:
        pickle.dump(0, cptFile)
    cpt = 0
    
    coups = {0: init(n)}
    while not verifVictoire(plateau, n):
        jouerUnCoup(plateau, n)
        cpt += 1
        with open("cpt","wb") as cptFile:
            pickle.dump(cpt, cptFile)
            
        coups[cpt] = plateau
            
    temps2 = time()
    print(
        "Bravo, tu as fini en "
        + str(cpt)
        + " mouvements et en "
        + str(round(temps2 - temps1,1))
        + " secondes !"
    )
    return cpt, round(temps2 - temps1,1), True

###################################################################################################################
####################################### Partie D : Annulation de coups ############################################
###################################################################################################################

def dernierCoup(coups: dict) -> tuple[int, int]:
    """Renvoie le dernier coup joué"""

    av_der = coups[len(coups) - 2]
    der = coups[len(coups) - 1]
    for i in range(3):
        if len(av_der[i]) < len(der[i]):
            tour_dep = i
        elif len(av_der[i]) > len(der[i]):
            tour_arr = i
    return (tour_dep, tour_arr)


def annulerDernierCoup(coups: dict):
    """Annule le dernier coups (modifie le dictionnaire)"""
    with open("cpt","rb") as cptFile:
        cpt = pickle.load(cptFile)
    
    dep, arr = dernierCoup(coups)
    effaceDisque(coups[cpt][arr][-1], coups[cpt], len(coups[0][0]))
    del coups[cpt]
    cpt -= 1
    with open("cpt","wb") as cptFile:
        pickle.dump(cpt, cptFile)
    print(coups[cpt][dep])
    dessineDisque(coups[cpt][dep][-1], coups[cpt], len(coups[0][0]))


###################################################################################################################
############################### Partie E : Comparaison des scores et temps de jeu #################################
###################################################################################################################

def sauvScore(joueur: str, nbDisques: int, nbCoups: int, temps: float):
    """Stocke les données d'une partie dans le dictionnaire scores (stocké en binaire dans le fichier data)"""

    with open("data", "rb") as data:
        scores = pickle.load(data)

    if joueur in scores:
        scores[joueur].append((nbDisques, nbCoups, temps))
    else:
        scores[joueur] = [(nbDisques, nbCoups, temps)]

    with open("data", "wb") as data:
        pickle.dump(scores, data)

def resetData():
    """ Reset les données du fichier data (dictionnaire vide)"""
    with open("data","wb") as data:
        pickle.dump({}, data)

def reflexionMoy() -> dict:
    """Récupère les scores et renvoie le temps moyen de réflexion par coup et par joueur"""
    
    with open("data","rb") as data:
        scores = pickle.load(data)
    
    tempsMoy = {}
    
    for joueur in scores:
        for partie in scores[joueur]:
            tempsMoy[joueur] = round(partie[2]/partie[1])
    
    return tempsMoy
            
def afficheScores(nb:int):
    """Affiche un tableau des meilleurs scores selon un nombre de disques donné sur la fenêtre turtle (classement en fonction du nombre de coups)"""
    
def afficheChronos(nb:int):
    """Affiche un tableau des meilleurs scores selon un nombre de disques donné sur la fenêtre turtle (classement en fonction du temps de jeu)"""
    
def afficheReflexMoy(nb:int):
    """Affiche un tableau des meilleurs scores selon un nombre de disques donné sur la fenêtre turtle (classement en fonction du temps de réflexion moyen)"""


###################################################################################################################
################################# Partie F : Jeu automatique, fonction récursive ##################################
###################################################################################################################

listeDep = []

def resolution(n: int, dep=0, arr=2, inter=1):
    """Modifie la liste des déplacements afin de résoudre le problème à n disques"""
    if n == 1:
        listeDep.append((dep, arr))
    else:
        resolution(n - 1, dep, inter, arr)
        listeDep.append((dep, arr))
        resolution(n - 1, inter, arr, dep)

def dessineRes(n:int, dep=listeDep):
    """Joue les dédplacements pour résoudre le problème à n disques"""
    tl.clear()
    dessinePlateau(n)
    config = init(n)
    for i in range(n):
        dessineDisque(i+1,config,n)
    for e in dep:
        tourDep, tourArr = e
        disque = config[tourDep][-1]
        effaceDisque(disque, config, n)
        config[tourDep].pop(-1)
        config[tourArr].append(disque)
        dessineDisque(disque, config, n)
    tl.done()


###################################################################################################################
############################################## Programme principal ################################################
###################################################################################################################

print("Bienvenue dans le jeu : Les tours de Hanoi !")

nb = int(tl.numinput("Les tours de Hanoï","Combien souhaitez-vous de disques en jeu ? ", minval = 1))
#tl.setup((80+(40 + 30 * (nb - 1))*3)*2,(20 + 20 * (nb + 1))*2)

dessinePlateau(nb)
for i in range(nb):
    dessineDisque(i + 1, init(nb), nb)

    
tl.onscreenclick(boutons)

coups, temps, victoire = boucleJeu(init(nb), nb)

if victoire:
    joueur = tl.textinput("Partie gagnée en "+str(coups)+" coup(s) et en "+str(temps)+" secondes !","Quel est votre nom ? ")
    sauvScore(joueur, nb, coups, temps)

sleep(3)
tl.bye()


with open("data", "rb") as data:
    print(pickle.load(data))


doctest.testmod()
tl.mainloop()

"""
resolution(9) 
dessineRes(9)
"""
